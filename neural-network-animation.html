<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animación Red Neuronal - Portafolio Jhylmar</title>
    <style>
        /* Reset y configuración básica */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #0a0a0a;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* Canvas principal para la animación */
        #neuralCanvas {
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0a0a0a 100%);
            box-shadow: inset 0 0 100px rgba(0, 255, 255, 0.1);
        }

        /* Overlay con información de carga */
        .loading-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 2rem;
            font-weight: 300;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
            z-index: 10;
        }

        .loading-text {
            margin-bottom: 20px;
            text-shadow: 0 0 20px #00ffff;
        }

        .loading-progress {
            width: 300px;
            height: 2px;
            background: rgba(0, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #00ffff;
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .loading-overlay {
                font-size: 1.5rem;
            }
            
            .loading-progress {
                width: 250px;
            }
        }
    </style>
</head>
<body>
    <canvas id="neuralCanvas"></canvas>
    
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-text">Inicializando Red Neuronal</div>
        <div class="loading-progress">
            <div class="loading-bar" id="loadingBar"></div>
        </div>
    </div>

    <script>
        // Configuración de la red neuronal
        class NeuralNetworkAnimation {
            constructor() {
                this.canvas = document.getElementById('neuralCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.loadingOverlay = document.getElementById('loadingOverlay');
                this.loadingBar = document.getElementById('loadingBar');
                
                // Configuración de dimensiones
                this.setupCanvas();
                
                // Configuración de la red neuronal
                this.config = {
                    layers: [4, 6, 3], // Nodos por capa: entrada, oculta, salida
                    nodeRadius: 12,
                    nodeGlowRadius: 25,
                    connectionWidth: 1.5,
                    animationSpeed: 100, // ms entre activaciones
                    colors: {
                        background: '#0a0a0a',
                        nodeInactive: '#2a2a3a',
                        nodeActive: '#00ffff',
                        nodeGlow: '#00ffff',
                        connection: '#ff00ff',
                        connectionActive: '#00ff00'
                    }
                };
                
                // Estado de la animación
                this.nodes = [];
                this.connections = [];
                this.animationState = {
                    currentLayer: 0,
                    currentNode: 0,
                    phase: 'nodes', // 'nodes' o 'connections'
                    isComplete: false,
                    progress: 0
                };
                
                this.init();
            }

            // Configurar el canvas para pantalla completa
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Redimensionar automáticamente
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                    this.calculatePositions();
                });
            }

            // Inicializar la red neuronal
            init() {
                this.calculatePositions();
                this.showLoadingOverlay();
                this.startAnimation();
            }

            // Calcular posiciones de nodos y conexiones
            calculatePositions() {
                this.nodes = [];
                this.connections = [];
                
                const layerSpacing = this.canvas.width / (this.config.layers.length + 1);
                
                // Crear nodos para cada capa
                this.config.layers.forEach((nodeCount, layerIndex) => {
                    const x = layerSpacing * (layerIndex + 1);
                    const nodeSpacing = this.canvas.height / (nodeCount + 1);
                    
                    for (let nodeIndex = 0; nodeIndex < nodeCount; nodeIndex++) {
                        const y = nodeSpacing * (nodeIndex + 1);
                        
                        this.nodes.push({
                            layer: layerIndex,
                            index: nodeIndex,
                            x: x,
                            y: y,
                            active: false,
                            glowIntensity: 0
                        });
                    }
                });
                
                // Crear conexiones entre capas adyacentes
                for (let layerIndex = 0; layerIndex < this.config.layers.length - 1; layerIndex++) {
                    const currentLayerNodes = this.nodes.filter(node => node.layer === layerIndex);
                    const nextLayerNodes = this.nodes.filter(node => node.layer === layerIndex + 1);
                    
                    currentLayerNodes.forEach(fromNode => {
                        nextLayerNodes.forEach(toNode => {
                            this.connections.push({
                                from: fromNode,
                                to: toNode,
                                active: false,
                                opacity: 0
                            });
                        });
                    });
                }
            }

            // Mostrar overlay de carga
            showLoadingOverlay() {
                this.loadingOverlay.style.opacity = '1';
            }

            // Ocultar overlay de carga
            hideLoadingOverlay() {
                this.loadingOverlay.style.opacity = '0';
            }

            // Actualizar progreso de carga
            updateProgress(progress) {
                this.loadingBar.style.width = progress + '%';
                this.animationState.progress = progress;
            }

            // Iniciar la animación
            startAnimation() {
                this.animationLoop();
            }

            // Bucle principal de animación
            animationLoop() {
                this.render();
                
                if (!this.animationState.isComplete) {
                    this.updateAnimation();
                    setTimeout(() => {
                        requestAnimationFrame(() => this.animationLoop());
                    }, this.config.animationSpeed);
                } else {
                    // Animación completada - continuar renderizado para efectos visuales
                    requestAnimationFrame(() => this.animationLoop());
                }
            }

            // Actualizar estado de la animación
            updateAnimation() {
                const totalLayers = this.config.layers.length;
                const currentLayerNodes = this.config.layers[this.animationState.currentLayer];
                
                if (this.animationState.phase === 'nodes') {
                    // Activar nodos de la capa actual
                    if (this.animationState.currentNode < currentLayerNodes) {
                        const nodeToActivate = this.nodes.find(node => 
                            node.layer === this.animationState.currentLayer && 
                            node.index === this.animationState.currentNode
                        );
                        
                        if (nodeToActivate) {
                            nodeToActivate.active = true;
                        }
                        
                        this.animationState.currentNode++;
                        
                        // Calcular progreso
                        let totalNodes = this.config.layers.reduce((sum, count) => sum + count, 0);
                        let activatedNodes = 0;
                        for (let i = 0; i < this.animationState.currentLayer; i++) {
                            activatedNodes += this.config.layers[i];
                        }
                        activatedNodes += this.animationState.currentNode;
                        this.updateProgress((activatedNodes / (totalNodes * 2)) * 100);
                        
                    } else {
                        // Todos los nodos de esta capa están activos, pasar a conexiones
                        this.animationState.phase = 'connections';
                        this.animationState.currentNode = 0;
                    }
                } else {
                    // Activar conexiones desde la capa actual
                    const connectionsFromCurrentLayer = this.connections.filter(conn => 
                        conn.from.layer === this.animationState.currentLayer
                    );
                    
                    if (this.animationState.currentNode < connectionsFromCurrentLayer.length) {
                        connectionsFromCurrentLayer[this.animationState.currentNode].active = true;
                        this.animationState.currentNode++;
                        
                        // Actualizar progreso para conexiones
                        let totalConnections = this.connections.length;
                        let activeConnections = this.connections.filter(conn => conn.active).length;
                        let nodeProgress = (this.config.layers.reduce((sum, count) => sum + count, 0) / (this.config.layers.reduce((sum, count) => sum + count, 0) * 2)) * 100;
                        this.updateProgress(nodeProgress + (activeConnections / totalConnections) * 50);
                        
                    } else {
                        // Todas las conexiones de esta capa están activas
                        this.animationState.currentLayer++;
                        this.animationState.phase = 'nodes';
                        this.animationState.currentNode = 0;
                        
                        if (this.animationState.currentLayer >= totalLayers) {
                            // Animación completada
                            this.animationState.isComplete = true;
                            this.updateProgress(100);
                            setTimeout(() => this.hideLoadingOverlay(), 1000);
                        }
                    }
                }
            }

            // Renderizar la red neuronal
            render() {
                // Limpiar canvas
                this.ctx.fillStyle = this.config.colors.background;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Renderizar conexiones
                this.renderConnections();
                
                // Renderizar nodos
                this.renderNodes();
            }

            // Renderizar conexiones
            renderConnections() {
                this.connections.forEach(connection => {
                    if (connection.active) {
                        // Crear gradiente para la conexión activa
                        const gradient = this.ctx.createLinearGradient(
                            connection.from.x, connection.from.y,
                            connection.to.x, connection.to.y
                        );
                        gradient.addColorStop(0, this.config.colors.connection);
                        gradient.addColorStop(1, this.config.colors.connectionActive);
                        
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = this.config.connectionWidth;
                        this.ctx.shadowColor = this.config.colors.connectionActive;
                        this.ctx.shadowBlur = 5;
                        
                        // Animar opacidad de la conexión
                        if (connection.opacity < 1) {
                            connection.opacity += 0.05;
                        }
                        this.ctx.globalAlpha = connection.opacity;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(connection.from.x, connection.from.y);
                        this.ctx.lineTo(connection.to.x, connection.to.y);
                        this.ctx.stroke();
                        
                        this.ctx.globalAlpha = 1;
                        this.ctx.shadowBlur = 0;
                    }
                });
            }

            // Renderizar nodos
            renderNodes() {
                this.nodes.forEach(node => {
                    if (node.active) {
                        // Animar intensidad del glow
                        if (node.glowIntensity < 1) {
                            node.glowIntensity += 0.08;
                        }
                        
                        // Efecto pulsante
                        const pulse = Math.sin(Date.now() * 0.003) * 0.3 + 0.7;
                        const currentGlow = node.glowIntensity * pulse;
                        
                        // Renderizar glow del nodo
                        const glowGradient = this.ctx.createRadialGradient(
                            node.x, node.y, 0,
                            node.x, node.y, this.config.nodeGlowRadius
                        );
                        glowGradient.addColorStop(0, `rgba(0, 255, 255, ${currentGlow * 0.8})`);
                        glowGradient.addColorStop(0.5, `rgba(0, 255, 255, ${currentGlow * 0.4})`);
                        glowGradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
                        
                        this.ctx.fillStyle = glowGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(node.x, node.y, this.config.nodeGlowRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Renderizar nodo principal
                        this.ctx.fillStyle = this.config.colors.nodeActive;
                        this.ctx.shadowColor = this.config.colors.nodeGlow;
                        this.ctx.shadowBlur = 10;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(node.x, node.y, this.config.nodeRadius, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Núcleo interno brillante
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.shadowBlur = 0;
                        this.ctx.beginPath();
                        this.ctx.arc(node.x, node.y, this.config.nodeRadius * 0.3, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                    } else {
                        // Nodo inactivo
                        this.ctx.fillStyle = this.config.colors.nodeInactive;
                        this.ctx.shadowBlur = 0;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(node.x, node.y, this.config.nodeRadius * 0.7, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
        }

        // Inicializar la animación cuando se carga la página
        window.addEventListener('load', () => {
            new NeuralNetworkAnimation();
        });

        // Reiniciar animación al hacer clic (opcional)
        window.addEventListener('click', () => {
            location.reload();
        });
    </script>
</body>
</html>
